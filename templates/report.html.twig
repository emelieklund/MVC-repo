{% extends "base.html.twig" %}

{% block title %}Report{% endblock %}

{% block body %}
    <h1>Report page</h1>

    <section>
    <a id="kmom01"><h2>Kmom01</h2></a>
        <p>Jag är bekant med objektorientering från ooPython-kursen då jag läste det kurspaketet förra året, men det är ju ett tag sedan nu. Mycket känner jag igen men vissa saker behöver jag nog repetera. Och sen är det ju ett annat språk nu också så det skiljer sig ju lite på så vis.</p>
        <p>I en PHP-klass kan man använda en konstruktor för att instansiera/sätta upp klassen, men det är inget krav då det också går att göra i efterhand. Variabler inom en klass benämns som medlemsvariabler eller properties. Dessa går att ha som public och nås då även utifrån klassen, men det är att föredra att ha dem som private, då man oftast inte vill att de ska gå att ändra på utifrån. Anger man en property som protected kan man nå den ifrån en klass som ärver från originalklassen. När man refererar till en property inom en klass, så används $this–>variable. Funktioner i klasser kallas metoder. För att skapa ett objekt av klassen skriver man $object = new Class();</p>
        <p>Det är många olika delar av kodbasen vi använder nu, med controllers och templates osv, så det är en del att hålla ordning på men det går nog fort att lära sig att hantera det. Jag tror att när man väl kommer in i det så kommer det att kännas väldigt strukturerat och trevligt.</p>
        <p>I ”PHP The Right Way” valde jag att fokusera lite extra på länken om Symfony Coding Standards (https://symfony.com/doc/current/contributing/code/standards.html) då det kändes relevant just nu. Mycket av det som stod där känns ganska universalt för de programmeringsspråk jag hittills har bekantat mig med, men en sak som kändes annorlunda med Symfony är följande punkt:</p>
        <li>Add a comma after each array item in a multi-line array, even after the last one;</li>
        <p>Det känns som att man oftast hoppar över kommatecknet efter sista. En annan punkt handlade om att man ska definiera en klass per fil, med undantaget private helper classes som inte ska användas utifrån. I artikeln skummade jag även igenom stycken som handlade om databaser. Det såg lite annorlunda ut från det vi har gjort tidigare så det ser jag fram emot att lära mig mer om.</p>
        <p>Min TIL för kmom01 är hur man definierar klasser i PHP.</p>
    </section>

    <section>
    <a id="kmom02"><h2>Kmom02</h2></a>
        <p>Kmom02 är äntligen klart och det har handlat om arv och komposition av klasser, samt lite om trait och interface. Arv innebär att en klass ärver alla egenskaper från en annan klass, men som också har en eller flera egna medlemsvariabler/konstanter/metoder utöver det. Komposition betyder att en klass består av en annan klass. En variation av komposition är aggregation, där kopplingen mellan klasserna är svagare. I det fallet så kan den ena klassen överleva om den andra förstörs, vilket inte är möjligt i vanlig komposition.</p>
        <p>Trait är en funktion som liknar arv, men är konstruerad på ett annat sätt. Traits kan användas av en klass för att utöka funktionaliteten. De är uppbyggda ungefär som klasser, och när de används av en klass så skriver man ”use <traitName>;”
            Interface är ett slags kontrakt. Det kan implementeras av en klass, och då lovar klassen att den ska erbjuda vissa metoder. Interface innehåller ingen kod i sig, utan visar bara vad en klass kan användas till.</p>
        <p>Uppgiften tycker jag har varit ganska utmanande och tidskrävande. Klasserna tyckte jag gick bra att implementera, dock hade jag lite problem med sessionerna samt JSON API:erna och där framför allt krav 5 var lite extra jobbigt. Sessionerna i sig var inte så svåra att få till, problemet var hur jag skulle visa upp dem i session-templaten. Eftersom jag sparar ”deck_session” som ett objekt (DeckOfCards), så kunde jag inte skriva ut det i templaten utan att göra om det till en array, så det fick jag göra först genom att använda getDeckSorted(). Därför är ”deck_session” hårdkodad i session-templaten, vilket jag inte är jättenöjd med. Key-värdena i sessionen (som just nu bara är ett), får jag fram genom en for-loop av array_keys($session->all()).</p>
        <p>Krav 5 i JSON API-delen löste jag med hjälp av formulär och en mellan-route ”get_nr”, som tar det angivna värdet från formuläret och sedan kör redirect till api/deck/draw/:number. Parametern ”number” skickar jag med som [’number’ => $num] och sedan skickas även talet 307 med som en tredje parameter, en lösning jag hittade på stackoverflow och som tydligen bevarar request-metoden då man annars bara kan köra redirect till en GET-route om jag har förstått saken rätt. Detta får faktiskt bli min TIL för kmom02. Spännande.</p>
        <p>Än så länge så tycker jag att vissa delar med Symfony och MVC-metoden har varit enkla att förstå, medan andra delar har varit väldigt utmanande. Det har krävts många googlingar och testningar. Nu känner jag dock att vissa saker börjar släppa lite. Jag hoppas att det fortsätter att vara en bra balans mellan utmaningar och uppenbarelser.</p>
    </section>

    <section>
    <a id="kmom03"><h2>Kmom03</h2></a>
        <p>Kmom03 avklarat. Att börja kursmomentet med att skapa ett flödesdiagram och skriva pseudokod tror jag absolut hjälpte mig att komma igång lite. Det gjorde att jag fick en ganska tydlig bild över helheten, även om jag inte fick med så mycket detaljer.</p>
        <p>Att implementera spelet tyckte jag gick bra. Det finns ju många scenarion i spelet som man behöver tänka på, men jag är nöjd med hur jag lyckades lösa det. På spelplanen visas första kortet från början, och sedan väljer man om man vill ta ett till kort eller stanna. Summan av korthanden visas. Om man har ett ess på handen så kommer två poäng-summor att visas, en där esset är värt 1 och en där esset är värt 14. Får man flera ess så kommer bara det ena att räknas som 14 i den alternativa summan, eftersom två ess är värda 28. Om en av poäng-summorna blir 21, så vinner man. Om man stannar och båda poängen är under 21, så kommer den högsta automatiskt att väljas.</p>
        <p>När det är bankens tur så sköts dragningarna av kort automatiskt med hjälp av JavaScripts setTimeout-funktion och window.location.href. Banken fortsätter att dra kort så länge summan är under 17.</p>
        <p>Jag är överlag nöjd med mina klasser och controller, men bland annat play-routen i GameController är lite stor och jag hade helst velat lägga en del kod i separata klasser, men jag testade mig fram och kom inte på något sätt att göra det på som inte gjorde att det blev ännu krångligare.</p>
        <p>Efter tre kursmoment med Symfony så känner jag att jag börjar få lite koll på det. Det känns för det mesta smidigt att använda. Jag tycker dock ibland att det är svårt att hitta information i dokumentationen. Ibland hittar man bättre tips på olika forum, och det känns ju lite skevt. Men jag antar att man får öva på att söka information också.</p>
        <p>Min TIL för kmom03 var hur man fick till en timeout-funktion i Twig med hjälp av JavaScript.</p>
    </section>

    <section>
    <a id="kmom04"><h2>Kmom04</h2></a>
        <p>Kmom04 och PHPUnit/Xdebug började inte så bra för mig då det tog mig flera dagar att lyckas installera det korrekt, men när jag väl hade gjort det så flöt det på bra med själva kodandet. PHPUnit känns lätt att använda och förstå, och det verkar vara ett bra verktyg för att testa sin kod.</p>
        <p>Jag lyckades få 100 % kodtäckning på alla klasser utom Game. Där fick jag tyvärr bara 60 %, då flera metoder använder sig av Session, vilket blev problematiskt i kombination med PHPUnit. Jag gjorde det bästa av situationen och hoppas att det kan vara okej ändå.</p>
        <p>Förutom problemet med Session så tycker jag att min kod känns testbar. Jag upplevde i alla fall inte att någon metod kändes svår att testa, och jag behövde inte heller skriva om någon del av koden. Game-klassen hade säkert kunnat bli bättre och mer testbar, men det var ingenting jag valde att lägga tid på nu eftersom jag ändå lyckades testa de flesta metoderna.</p>
        <p>Jag tycker ändå att testbar kod och ren kod går lite hand i hand. För att kunna veta exakt vad koden gör och således kunna testa samtliga metoder, så behöver koden vara väldokumenterad och lätt att tolka. Det kommer i alla fall hjälpa till att göra testningen mer effektiv då man inte behöver sitta och fundera så mycket på vad koden gör.</p>
        <p>Min TIL för kmom04 är hur man enhetstestar med olika assertions i PHP.</p>
    </section>

    <section>
    <a id="kmom05"><h2>Kmom05</h2></a>
        <p>Jag tycker att det gick ganska bra med kmom05 och övningen med Symfony och Doctrine. Det var många nya begrepp och jag hade lite svårt att förstå vissa saker med en gång, men så brukar det vara för mig. För mig brukar polletten trilla ner när jag själv sätter igång med själva kodandet. Jag tycker att det är lättare att förstå teorin när jag har börjat med det praktiska. Något jag reagerade på var hur smidigt det gick att skapa en databas med ORM/Doctrine, istället för att behöva skriva all SQL-kod själv.</p>
        <p>Applikationen jag byggde i detta kursmoment tyckte jag påminde lite om E-shopen vi gjorde i databas-kursen. Därför kunde jag återanvända lite kod till formulär bland annat, vilket sparade mig lite tid. Jag valde att lägga in fem bok-klassiker i mitt bibliotek. De presenteras i en tabell på landningssidan, och därifrån kan man trycka på titeln till varje bok för att komma till en separat sida som visar enbart den boken. Därifrån kan man också klicka sig vidare till ”Update details” och ”Delete book”. Det känns som att jag fick till ett enkelt sätt att navigera sig på sidan.</p>
        <p>Att jobba med CRUD i ORM/Doctrine tycker jag gick bra eftersom det var en tydlig och väldigt hjälpsam övning/föreläsning som guidade mig igenom alla steg. Det är såklart lite annorlunda från sättet vi är vana vid att arbeta när det kommer till databaser, men man ser ju ändå lite likheter också. Det underlättar nog mycket att kunna databaser när man jobbar med ORM, även om det inte är ett krav.</p>
        <p>Jag kan tänka mig att ORM är otroligt användbart och lätt att jobba med när man väl har fått koll på alla begrepp och funktioner, men det tar nog lite tid att lära sig. Om man jämför med t ex hur vi jobbade mot databaser med hjälp av JavaScript i databas-kursen så känns det lite krångligare nu då det är mer inbyggda funktioner etc att hålla reda på. Där använde vi ju också SQL, vilket vi inte gör på samma sätt i ORM.</p>
        <p>Min TIL för kmom05 är hur man lägger till nya rader i en databas med ORM.</p>
    </section>

    <section>
    <a id="kmom06"><h2>Kmom06</h2></a>
        <p>PHP Metrics tyckte jag hade många användbara funktioner. Jag kollade mest på violations, average cyclometic complexity och average bugs. Det var framför allt complexity som stack ut för mig, så där fick jag ut många förslag till förbättringar. Jag tittade även lite på LCOM. Coupling kollade jag på lite grann men insåg ganska snabbt att jag inte kunde göra så mycket åt det. Dessutom hade jag inga extrema värden där.</p>
        <p>Scrutinizer gick bra att få igång och vissa delar tyckte jag var lätta att tolka direkt. Däremot tror jag att användarvänligheten skulle kunna förbättras lite då vissa saker är lite svåra att hitta. T ex hot spots borde ligga lite mer synligt då det är något som känns väldigt relevant och som man kanske vill kolla på ofta. Från början fick jag 19 % kodtäckning och 9.92 i kodkvalitet. Efter förbättringarna hade jag 21 % kodtäckning och 9.95 i betyg.</p>
        <p>Jag tror att det är viktigt och kanske till och med avgörande att hålla en bra och ren kod som följer en kodstandard, för att man lätt ska kunna gå tillbaka och förstå och underhålla sin kod. Att använda beskrivande namn och kommentera och dokumentera koden, både för sig själv och för andra personer i teamet eller kunden. Det är såklart också viktigt ur prestanda-perspektiv, att t ex inte ha onödigt många rader kod. Att redan från början av ett projekt börja testa koden och använda mätverktyg kommer nog hjälpa till enormt mycket.</p>
        <p>Min TIL för kmom06 är hur man kan förbättra sin kod genom att kolla på komplexitet.</p>
    </section>

    <section>
    <a id="kmom07-10"><h2>Kmom07-10</h2></a>
        <h3>Krav 1-3</h3>
        <p>I det här projektet valde jag att implementera patiensen Poker Squares. I spelet kan man välja att betta, och det gör man genom att fylla i hur många poäng man tror att man minst kommer att få och hur mycket pengar man vill betta. Under spelets gång kan spelaren välja att trycka på ”Give me a clue” (max tre gånger) för att få tips om var man kan placera kortet, och då visas poängen som alla rader/kolumner kommer att generera om man placerar kortet där. Funktionen funkar bara på en kolumn/rad som redan har fyra placerade kort. Spelaren kan en gång under spelet välja att byta bort ett kort.</p>
        <p>Jag har använt Card-klasserna från tidigare kursmoment, men har också skapat sex nya klasser till det här spelet: CardHolder, GameBoard, PokerSquares, PokerHand, Betting och Clue. Klassen CardHolder hanterar rutorna som korten placeras i, och de består av holderId (1-25) och holderCard (default null men ändras till kortets namn när det placeras där). I GameBoard skapas själva spelplanen genom att bland annat skapa alla kolumner/rader som består av arrayer av korthållarnas ID och kortnamn. PokerSquares-klassen tar en full kolumn/rad som parameter, och i metoden whichPokerHand() returneras hur många poäng korthanden är värd (0-100 beroende på poker-hand). I PokerHand finns alla poker-händer som metoder, från ettpar till royal straight flush, och de returnerar true eller false. Klassen Betting tar poängen som spelaren gissade och poängen som spelaren fick som parametrar, och beräknar utifrån resultatet hur mycket spelaren vann/förlorade. I Clue skapas en teoretiskt full kolumn/rad genom att ta en kolumn med fyra placerade kort och det nuvarande kortet som ska placeras, och sedan används whichPokerHand() för att visa hur många poäng den kolumnen/raden skulle ge om man placerade kortet där.</p>
        <p>I PokerSquaresController finns en route som initierar spelet, en route som hanterar om man valde att lägga ett bet och en route för om man valde att inte betta. I play-routen hanteras kolumnerna/raderna och deras respektive poäng, och här renderas också templaten med spelplanen. När man trycker på en kortruta där man vill placera nuvarande kort, så hamnar man i routen /proj/place/{id}/{card} och där placeras kortet på rätt ställe, och sedan dras ett nytt kort. Sedan finns en route som sköter om clue-delen, en som sköter om new card, en för about och en för about databases.</p>
        <p>Kodtäckningen på Scrutinizer visar 32 %, men alla vanliga klasser har 100 %. Jag har dock valt att inte enhetstesta controllers och databaserna.        </p>
        <h3>Krav 4</h3>
        <p>Jag har skapat en kontroller, JSONPokerSquaresController, som hanterar JSON API:s relaterade till Poker Squares. I /proj/api finner man fem olika routes som är kopplade till spelet. En som visar highscores (kopplade till databasen Highscore som jag berättar om i krav 5), en som visar samtliga kolumner (uppdateras under spelets gång), och en som på samma sätt visar alla rader. Man kan också se alla användare (databasen User) samt söka efter en specifik användare. Då används metoden findUserByUsername() som återfinns i UserRepository.</p>
        <h3>Krav 5</h3>
        <p>Jag har gjort två databas-tabeller via ORM, Highscore och User. I Highscore sparas highscore efter en avslutad spelomgång och består av id, name och score. Man kan se alla highscores i en lista, och där kan man också radera dem. Tabellen User består av id, username, account och highscore. Under fliken User kan man se alla användare, men också skapa en ny. Då fyller man bara i ett användarnamn. Account har ett default-värde på 100, som en liten startpott. Kolumnen highscore är från början null, men ändras efter att spelaren har avslutat första spelomgången och sedan kommer den bara att uppdateras om den förbättras. Man kan nollställa databasen genom att gå in på About/About database. Jag valde att inte enhetstesta databaserna.</p>
        <h3>Krav 6</h3>
        <p>Jag har gjort några features utanför baskraven. Det första jag vill lyfta fram är Clue-delen, där man kan se hur många poäng en rad/kolumn kommer att generera om det nuvarande kortet placeras på den sista tomma rutan. Jag tänkte att det skulle bli en lite halvavancerad sak att implementera, men jag tycker att jag löste det ganska snyggt med lite kod och återanvändning av en annan klass.</p>
        <p>Jag gjorde också två sätt att spela spelet på, antingen betta eller inte betta. Detta krävde att jag gjorde två olika routes som hanterar varje utfall, samt två olika formulär för att spara highscore när spelomgången är slut. Det ena har användarnamnet ifyllt redan och i det andra får man fylla i det själv. Bettar man så involverar man dessutom båda databaserna.</p>
        <p>Den tredje saken är funktionen att kunna byta bort ett kort. Ingen direkt avancerad funktion men det krävdes ändå att jag flyttade om lite kod och en session som sätter ”new_card” till ”used”.</p>
        <h3>Övrigt</h3>
        <p>Projektet har i sin helhet gått bra att implementera. Vissa delar har varit ganska kluriga att få till, t ex spelplanen och att få till hur korten ligger. Poängräkningen var lite svår att få till också. När jag nästan var klar med allt så kom jag på att det gick väldigt lätt att fuska då ett nytt kort drogs genom att bara uppdatera sidan, då korten från början drogs i samma route som renderar sidan. Därför fick jag flytta runt koden lite, så att första kortet dras i routen som initierar spelet, och alla nästkommande kort dras i routen som sparar korten. Generellt så tycker jag att projektet kändes relativt svårt men ändå på en rimlig nivå. Jag önskar att jag hade kommit på någon extra feature till spelet, men fantasin tog slut och likaså tiden. Det har i alla fall varit väldigt kul och det har inte alls känts jobbigt att slutföra projektet, och jag tycker också att det har sammanfattat kursen på ett bra sätt genom att involvera delar från samtliga kursmoment.</p>
        <p>Kursen har haft stor variation och det känns som att jag har fått med mig mycket ny kunskap i ryggsäcken. Det har varit roliga kursmoment, vilket underlättar mycket. Det har varit bra föreläsningar och jag gillar upplägget med att dela upp en föreläsning i flera kortare klipp. Det har också funnits mycket annat material i form av övningar och artiklar. Jag är jättenöjd med kursen och skulle absolut rekommendera den till personer med intresse för webbprogrammering. Jag ger kursen 9/10 i betyg.</p>
    </section>
{% endblock %}
